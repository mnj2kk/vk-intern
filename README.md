# Система автоматического дополнения запросов

В данной статье рассказано о задаче и подходу к её решению

## Постановка задачи

> Написать систему автоматического дополнения запросов, которая на запрос 
пользователя будет выдавать на основе датасета не более 5 лучших подсказок
## Подход к реализации

Основополагающим компонентом в реализации будут прямые и обратные индексы. В кратце, прямой индекс - это номер запроса в нашем датасете, а обратный индекс это слово и соответвующие ему номера запросов, в которых оно встречается. 

На введенный пользователем запрос мы будем для каждого слова (префикса) искать набор прямых индексов, в которых оно встречается и пересекать их, получая нужные набор подсказок. 

Для быстрого поиска префиксов мы будем использовать бор (т.к. поиск префикса в нем происходит `O(|prefix|)`).

Чтобы ранжировать наши подсказки будем сортировать изначальный датасет, таким образом, что чем выше занимает позицию запрос - тем он имеет больший приоритет.

Ранжирование происходит следующим образом:
<ol>
  <li> Сравниваются по порядку слова в запросах, если слово из первого запроса имеет большее вхождение в датасет, то они остаются на своих местах, если наоборот, то меняются. В случае равенства кол-ва вхождений переходим к следующему пункту. </li>
  <li> Сравниваем слова лексикографически. Лексикографически меньшее слово должно стоять выше. В случае, если слова лексикографически идентичные, то переходим к следующему пункту. </li>
  <li> В случае, если слова в запросах закончились, то сравниваем кол-во слов в запросах (меньшее кол-во занимает позицию выше). </li>
</ol>

## Задействованые библиотеки / фреймворки / язык программирования

Основной язык программирования: `C++ 20`

Библиотеки: Стандартные библиотеки, такие как: `vector; map; string; fstream; unordered_map; sstream; etc..`

Фреймворки: не задействованы 

## Оценка эффективности данного подхода

Основная проблема данного подхода - то что все данные хранятся в RAM. На очень больших датасетах данное решение надо будет распределять на несколько серверов. Но в рамках подхода к тестовой задаче данное решение подходит.

Возможные оптимизации:

<ol>
  <li> Индексы для каждого эллемента в боре можно хранить в БД, что сэкономит оперативную память. </li>
  <li> Будут добавляться.. </li>
</ol>
